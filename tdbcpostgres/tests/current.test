# tdbcpostgres.test --
#
#	Tests for the tdbc::postgres bridge
#
# Copyright (c) 2008 by Slawomir Cygan
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
#
#------------------------------------------------------------------------------

lappend auto_path .
package require tdbc::postgres
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
}

# We need to know the parameters of the Postgre database for testing.

set connFlags {}
if {[info exists env(TEST_HOST)]} {
    lappend connFlags -host $env(TEST_HOST)
}
if {[info exists env(TEST_USER)]} {
    lappend connFlags -user $env(TEST_USER)
}
if {[info exists env(TEST_PASSWD)]} {
    lappend connFlags -password $env(TEST_PASSWD)
}
if {[info exists env(TEST_DB)]} {
    lappend connFlags -db $env(TEST_DB)
} else {
    lappend connFlags -db tdbc_test
}
if {[info exists env(TEST_PORT)]} {
    lappend connFlags -port $env(TEST_PORT)
}

#------------------------------------------------------------------------------
test tdbc::postgres-1.1 {create a connection, wrong # args} {*}{
    -body {
	tdbc::postgres::connection create
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test tdbc::postgres-1.2 {create a connection, connection string missing} {*}{
    -body {
	tdbc::postgres::connection create db -user
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test tdbc::postgres-1.3 {create a connection, bad arg} {*}{
    -body {
	tdbc::postgres::connection create db -rubbish rubbish
    }
    -returnCodes error
    -match glob
    -result {bad option "-rubbish"*}
}

test tdbc::postgres-1.4 {create a connection, bad port} {*}{
    -body {
	tdbc::postgres::connection create db -port rubbish
    }
    -returnCodes error
    -result {expected integer but got "rubbish"}
}

test tdbc::postgres-1.5 {create a connection, bad port} {*}{
    -body {
	tdbc::postgres::connection create db -port 999999999999
    }
    -returnCodes error
    -result {integer value too large to represent}
}

test tdbc::postgres-1.6 {create a connection, bad port} {*}{
    -body {
	tdbc::postgres::connection create db -port -1
    }
    -returnCodes error
    -result {port number must be in range [0..65535]}
}

test tdbc::postgres-1.7 {create a connection, bad port} {*}{
    -body {
	tdbc::postgres::connection create db -port 65536
    }
    -returnCodes error
    -result {port number must be in range [0..65535]}
}

test tdbc::postgres-1.8 {create a connection, failure} {*}{
    -body {
	set status [catch {
	    tdbc::postgres::connection create db -host rubbish.example.com
	} result]
	list $status $result $::errorCode
    }
    -match glob
    -result {1 {could not translate host name*} {TDBC GENERAL_ERROR HY000 POSTGRES *}}
}

test tdbc::postgres-1.9 {create a connection, successful} {*}{
    -body {
	tdbc::postgres::connection create ::db {*}$connFlags
    }
    -result ::db
    -cleanup {
	catch {rename ::db {}}
    }
}


#------------------------------------------------------------------------------
#
# The tests that follow all require a connection to a database.

tdbc::postgres::connection create ::db {*}$connFlags
catch {::db allrows {DROP TABLE people}}

#------------------------------------------------------------------------------

test tdbc::postgres-2.1 {prepare statement, wrong # args} {*}{
    -body {
	::db prepare
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
}

test tdbc::postgres-2.2 {don't make a statement without a connection} {*}{
    -body {
	tdbc::postgres::statement create stmt rubbish moreRubbish 
    }
    -returnCodes error
    -result {rubbish does not refer to an object}
}

test tdbc::postgres-2.3 {don't make a statement without a connection} {*}{
    -body {
	tdbc::postgres::statement create stmt oo::class moreRubbish 
    }
    -returnCodes error
    -result {oo::class does not refer to a Postgres connection}
}

test tdbc::postgres-2.4 {semicolons in statements} {*}{
    -body {
	::db prepare {select foo from bar; select grill from quux}
    }
    -returnCodes error
    -result {tdbc::postgres does not support semicolons in statements}
}


test tdbc::postgres-3.1 {prepare an invalid statement} {*}{
    -body {
	set status [catch {
	    ::db prepare {
		RUBBISH
	    }
	} result]
	list $status $result $::errorCode
    }
    -match glob
    -result {1 {*syntax error*} {TDBC SYNTAX_ERROR* 42601 POSTGRES *}}
}

test tdbc::postgres-3.2 {prepare a valid statement} {*}{
    -body {
	set stmt [::db prepare {
	    CREATE TABLE people(
		idnum INTEGER PRIMARY KEY,
		name VARCHAR(40) NOT NULL
	    )
	}]
    }
    -match glob
    -result *Stmt*
    -cleanup {
	catch [rename $stmt {}]
    }
}

test tdbc::postgres-3.3 {execute a valid statement with no results} {*}{
    -body {
	set stmt [::db prepare {
	    CREATE TABLE people(
		idnum INTEGER PRIMARY KEY,
		name VARCHAR(40) NOT NULL
	    )
	}]
	set rs [$stmt execute]
	list [expr {[$rs rowcount] <= 0}] [$rs columns] [$rs nextrow nothing]
    }
    -result {1 {} 0}
    -cleanup {
	catch {
	    rename $rs {}
	    rename $stmt {}
	    set stmt [::db prepare {
		DROP TABLE people
	    }]
	    set rs [$stmt execute]
	    rename $rs {}
	    rename $stmt {}
	}
    }
}

test tdbc::postgres-3.4 {result set: wrong # args} {*}{
    -body {
	set stmt [::db prepare {
	    CREATE TABLE people(
		idnum INTEGER PRIMARY KEY,
		name VARCHAR(40) NOT NULL
	    )
	}]
	$stmt execute with extra args
    }
    -returnCodes error
    -match glob
    -result {wrong # args*}
    -cleanup {
	catch [rename $stmt {}]
    }
}

test tdbc::postgres-3.5 {result set: trying to create against a non-object} {*}{
    -body {
	tdbc::postgres::resultset create rs nothing
    }
    -returnCodes error
    -result {nothing does not refer to an object}
}

test tdbc::postgres-3.6 {result set: trying to create against a non-statement} {*}{
    -body {
	tdbc::postgres::resultset create rs db
    }
    -returnCodes error
    -result {db does not refer to a MySQL statement}
}

#-------------------------------------------------------------------------------
#
# Following tests need a 'people' table in the database.
# They also need to use the InnoDB engine, because some of the test cases
# test transaction support.

set stmt [::db prepare {
    CREATE TABLE people(
	idnum INTEGER PRIMARY KEY,
	name VARCHAR(40) NOT NULL,
	info INTEGER
    )
}]
set rs [$stmt execute]
rename $rs {}
rename $stmt {}

test tdbc::postgres-4.1 {execute an insert with no params} {*}{
    -body {
	set stmt [::db prepare {
	    INSERT INTO people(idnum, name, info) values(1, 'fred', 0)
	}]
	set rs [$stmt execute]
	list [$rs rowcount] [$rs columns] [$rs nextrow nothing]
    }
    -result {1 {} 0}
    -cleanup {
	catch {
	    rename $rs {}
	    rename $stmt {}
	    set stmt [::db prepare {
		DELETE FROM people
	    }]
	    set rs [$stmt execute]
	    rename $rs {}
	    rename $stmt {}
	}
    }
}

test tdbc::postgres-4.2 {execute an insert with variable parameters} {*}{
    -body {
	set stmt [::db prepare {
	    INSERT INTO people(idnum, name, info) values(:idnum, :name, 0)
	}]
	$stmt paramtype idnum integer
	$stmt paramtype name varchar 40
	set idnum 1
	set name fred
	set rs [$stmt execute]
	list [$rs rowcount] [$rs columns] [$rs nextrow nothing]
    }
    -result {1 {} 0}
    -cleanup {
	catch {
	    rename $rs {}
	    rename $stmt {}
	    set stmt [::db prepare {
		DELETE FROM people
	    }]
	    set rs [$stmt execute]
	    rename $rs {}
	    rename $stmt {}
	}
    }
}
